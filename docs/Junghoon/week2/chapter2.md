# 2장: 리액트 핵심 요소 깊게 살펴보기

## 렌더링과 최적화에 대하여

### 렌더링의 정의

> HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미합니다.  
> 브라우저에서 사용자에게 보여줄 정보를 시각적으로 표현하는 과정이기 때문에 매우 중요하며, 이 과정이 어떻게 이루어지는지에 따라 성능에도 큰 영향을 미칩니다.

### 리액트에서의 렌더링

> 리액트에서의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 생성하는 과정을 말합니다.
> 리액트 애플리케이션 트리 안의 모든 컴포넌트는 현재 자신이 가진 `props`와 `state`를 기반으로 UI를 구성하고, 이에 따른 DOM 결과를 계산하여 브라우저에 전달합니다.

리액트의 렌더링은 시간과 리소스를 소비하는 작업입니다. 이 비용은 결국 웹사이트 방문자에게 전달되며, 복잡하거나 느린 렌더링은 사용자 경험을 저하시킬 수 있습니다. 따라서 렌더링의 **순서와 조건을 이해하고, 그 과정을 최소화하는 것**이 중요합니다.

#### 렌더링의 종류

- **최초 렌더링**: 사용자가 애플리케이션에 처음 진입할 때 수행됩니다.
- **리렌더링**: 최초 렌더링 이후에 발생하는 모든 렌더링을 의미합니다.

#### 리렌더링이 발생하는 경우

- 클래스 컴포넌트에서 `setState()`가 호출된 경우
- 클래스 컴포넌트에서 `forceUpdate()`가 호출된 경우

<details>       
<summary>forceUpdate()가 뭐지..?</summary>

`forceUpdate()`는 React 클래스 컴포넌트에서 강제로 리렌더링을 트리거하는 메서드입니다.  
보통은 `setState()`로 리렌더링하지만, 외부 상태나 직접적인 변화가 필요할 때 사용됩니다.

⚠️ `render()` 내부에서 호출하면 무한 루프가 발생할 수 있으므로 사용에 주의해야 합니다.

</details>

- `render()`가 `state`나 `props`가 아닌 다른 외부 값에 의존하는 경우 사용
- 함수 컴포넌트에서 `useState()`의 setter 함수 호출
- `useReducer()`의 `dispatch()` 함수 호출
- 컴포넌트의 `key` prop이 변경된 경우
- 부모 컴포넌트가 리렌더링될 경우 자식 컴포넌트도 무조건 리렌더링됨
- `props`가 변경된 경우 → 자식 컴포넌트도 업데이트 필요

---

### 리액트의 렌더링 프로세스

렌더링은 두 단계로 나뉩니다 : `렌더(Render) 단계`와 `커밋(Commit) 단계`

### 1. 렌더 단계

- 컴포넌트를 실행하여 가상 DOM을 생성하고
- 이전 가상 DOM과 비교(Diffing)
- 변경된 사항이 있는 컴포넌트를 체크
- 비교 기준: `type`, `props`, `key`

### 2. 커밋 단계

- 렌더 단계에서 변경이 감지된 경우에만 실행됩니다.
- 실제 DOM을 변경하고 사용자에게 보여지는 화면에 반영합니다.

> 🗣️ 렌더링이 수행되더라도 변경 사항이 없으면 커밋 단계는 생략될 수 있습니다.

---

### 리액트 18의 동시성 렌더링 (Concurrent Rendering)

> 렌더링이 비동기적으로 진행될 수 있는 새로운 방식입니다.  
> 렌더링 중간에 작업을 **중단, 우선순위 조정, 재시작, 포기**하는 것이 가능합니다.

이를 통해 다음과 같은 최적화가 가능해집니다

- 긴 렌더링 작업 중에도 사용자 입력에 빠르게 반응
- 더 낮은 우선순위의 작업은 나중으로 미룰 수 있음
- 여러 UI 상태가 동시에 그려지는 상황 방지

---

### 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

#### 리액트의 최적화 도구들

- `useMemo`
- `useCallback`
- 고차 컴포넌트 `React.memo`

> 대부분의 개발자가 이들이 **렌더링 최적화에 쓰인다는 점은 알지만**, **언제 어떻게 써야 하는지**에 대해서는 혼동하기 쉽습니다. 이에 두 가지 주장이 있습니다.

#### 공통 전제

> 일부 컴포넌트는 메모이제이션이 성능에 도움이 될 수 있습니다.
> 특히 렌더링이 자주 일어나고, 내부 연산이 비싸며, 자식 컴포넌트가 많은 경우.

#### 1. 필요한 곳에만 메모이제이션을 적용하자

- 메모이제이션도 비용이 듭니다
  - 값 비교 비용
  - 캐시 유지 비용
- 리액트 공식 문서 인용

> `useMemo`는 성능 최적화를 위한 도구일 뿐, 그 자체로 **성능을 보장하는 것은 아닙니다**.  
> 가까운 미래에 리액트는 캐시를 잊어버리고 재계산하는 전략을 채택할 수도 있다고 합니다.

**권장 접근 방식**:  
작동하는 코드를 먼저 작성 → 개발자 도구나 `useEffect` 등을 통해 렌더링 분석 → 꼭 필요한 곳에만 최적화 도입

#### 2. 일단 전부 메모이제이션하자

> “렌더링 비용이 비싸므로 전부 메모이제이션하는 게 낫다”는 주장도 있습니다.

- 실수로 메모이제이션을 빠뜨렸을 때 생기는 성능 저하가 더 크기 때문
- 이는 **초기 과잉 최적화**일 수 있으나, 실전에서 실수를 줄일 수 있음
