# JSX란?

-   XML과 유사한 내장형 구문으로, 리액트에 종속적이지 않은 독자적인 문법
-   javascript 표준의 일부는 아님.
-   (핵심) `트리 구조로 표현하고 싶은 다양한 것들을 작성해두고 이를 트랜스파일 과정을 통해 자바스크립트가 이해할 수 있는 코드로 변경하기 위한 수단`!!!!!

## JSX의 정의

### 구성 요소

-   JSXElement : HTML의 `element`와 비슷한 역할

    -   JSXOpeningElement : `<JSXElement JSXAttributes(optional)>`
    -   JSXClosingElement : `</JSXElement>`
    -   JSXSelfClosingElement : `<JSXElement JSXAttributes(optional)/>`
    -   JSXFragment : `<>JSXChildren(optional)</>`
        형태 중 하나여야 함

    이러한 요소를 컴포넌트로 사용할 때 `대문자`로 시작하지 않으면 안 된다는 것은 알고 있었는데, 소문자로 시작하는 요소로 사용했을 때 `컴포넌트`가 아닌 `HTML`태그로 인식되어 실행되지 않는다는 것은 처음 알게 되었음

-   JSXAttributes : JSXElement에 부여할 수 있는 속성(optional) `Name : value` 형태로 사용되거나 SpreadAttributes로 활용

    -   JSXSpreadAttributes : `<button {...props}></button>` 형태이며 속성 확장, 오버라이드 등에 활용
    -   JSXAttributeName : 속성의 키 값, `:`를 이용해 키를 나타낼 수 있음
    -   JSXAttributeValue : `""`, `''`, `{AssignmentExpression}`, `JSXElement` 중 하나의 형태를 만족해야하며 속성의 키에 할당할 수 있는 값을 나타냄

-   JSXChildren : JSXElement의 자식 값을 나타냄(0개 이상)
    -   JSXText : `{}, <>` 을 제외한 문자열, 이를 사용하고 싶다면 다른 문자열로 표시
    -   JSXElement, JSXFragment, {JSXChildExpression} 이 내용들도 children으로 들어갈 수 있음
-   JSXStrings

# JSX -> javascript

```javascript
const Component = <A required={true}>Hello world<A/>
```

```javascript
var ComponentA = React.createElement(A, { required: true }, 'Hello World');
```

와 같음, 따라서 우리가 React에서 사용하는 JSX가 결국엔 createElement로 귀결된다는 사실을 파악한다면

```jsx
return isHeading ? <h1 className="text">{children}</h1> : <span className="text">{children}</span>;
```

처럼 불필요한 코드 중복이 나타나는 삼항 연산자 구문을

```jsx
return createElement(isHeading ? 'h1' : 'span', { className: 'text' }, children);
```

으로 더 가독성있고 간결하게 처리할 수 있음

# 가상 DOM의 탄생 배경

### 브라우저 렌더링 과정

1. HTML 다운로드
2. HTML 파싱 후 트리(DOM) 생성
3. 파싱하면서 CSS를 만나면 CSS 파일도 다운로드
4. CSS 파일도 파싱하면서 CSSOM 생성
5. 레이아웃, 페인팅 하면서 렌더링...

하는 과정을 통해 렌더링을 함
하지만 요즘 대다수의 앱은 렌더링 된 이후 정보를 보여주는 데 그치지 않고, 사용자의 인터랙션을 통해 다양한 정보를 노출함

특히 SPA에서는 처음부터 HTML을 새로 받아서 렌더링 과정을 시작하는 일반적인 웹 페이지와는 다르게 `메모리를 누적하여 사용`하고, `가비지 컬렉션 부담`, `복잡한 상태 추적`, `상태 변화 전파`등의 이유로 이러한 DOM 작업이 더 부담이 큼

### 이러한 문제를 해결하기 위해 등장한 `가상 DOM`

-   일반적인 DOM을 사용하는 것보다 무조건 빠른 것이 아니라 대부분의 상황에서 충분히 빠르다는 것

### 리액트 파이버(Fiber)

-   리액트의 내부 재조정 엔진 아키텍처
-   리액트 컴포넌트를 표현하는 자바스크립트 객체
-   Element가 화면에 표시할 내용을 설명하는 객체라면, 파이버는 그 요소를 실제로 처리하고 관리하는 내부 객체임.
-   운영체제에서 프로세스, 스레드마다 할당된 관리 구조체와 비슷한 느낌..?(PCB, TCB..)
-   element에 하나씩 매핑되는 1:1 관계임
-   이 Fiber는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행됨,,
-   이러한 작업들은 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 가능한 한 빠르게 처리하거나, 낮은 작업을 연기시키는 등 스케줄링을 하기도 함!!(OS 스케줄링과 완전 완전 유사)

# Fiber에 대해 더 깊게 알아보기...

위 내용에도 적어놨듯 Fiber는 운영체제의 프로세스, 스레드와 매우매우 유사하고 기능 또한 스케줄링과 유사하여 흥미가 생겼습니다!

Fiber의 기능이 뭔지, Fiber가 있을 때와 없을 때를 비교하여 설명을 하자면

### Fiber가 없는 경우(React 15버전 이전)

이 당시에는 재조정(책에 나와있듯, 어떤 부분을 새롭게 렌더링해야 하는지, 가상 DOM과 실제 DOM을 비교하는 작업 또는 알고리즘) 과정이 재귀적이고 동기적으로 이루어져 있었음

> 문제점

```jsx
function DataTable() {
    const [data, setData] = useState(initialData); // 1000개의 아이템이라고 가정
    return(
        <div>
            <button onClick = {() => setData(newData)}>데이터 업데이트</button>
            <table>
                {data.map(item=>(<TableRow key={item.id} data={item}>))}
            </table>
        </div>
    );
}
```

-   이런 상황에서 데이터 업데이트를 하는 순간 1000개의 행을 모두 다시 계산해야하는데 이 작업이 동기적으로 발생하기 때문에 중단 없이 한 번에 이루어지게 됨!!
-   -> 이 동안에는 스크롤, 입력, 애니메이션 등 어떤 작업도 할 수 없기 때문에 이 1000개의 행이 업데이트 되는 동안 사용자는 UI가 멈춰있는 듯한 느낌을 받게 됨(사실 멈춘게 맞음)

> 파이버가 있으면?

-   테이블 업데이트가 여러 작은 작업으로 나뉨(OS에서 task와 같은 느낌)
-   ex. 한 프레임에 20개 행씩 처리하고 브라우저에게 Control 반환
-   이로 인해 브라우저는 20개 행을 처리하고 받은 Control로 input, scroll, animate등의 작업을 수행할 수 있음

### 파이버의 역할

즉, 파이버의 핵심 기능은 `스케줄링` 이라고 볼 수 있음
파이버가 도입한 주요 스케줄링 관련 기능들은

-   작업 우선순위 지정
    -   타이핑, 클릭, 스크롤(높은 우선순위)
    -   데이터 업데이트(일반 우선순위)
    -   오프스크린 컴포넌트(낮은 우선순위)
        이와 같이 작업별로 우선순위를 사전에 정해두고 이에 따른 스케줄링을 진행
-   시간 분할(Time slicing)
    -   각 작업을 5~10ms 단위로 쪼개서 처리함
    -   한 단위 작업후 브라우저에게 제어권 반환(리눅스 스케줄링에서 할당된 시간을 다 쓰면 다시 레디 큐로 돌아가는 작업과 유사)

와 같은 기능들(스케줄링 관련)을 통해 자바스크립트가 싱글 스레드에서 실행되지만, 사용자는 마치 여러 작업이 동시에 처리되는 것처럼 느낄 수 있음!

### 리눅스 스케줄링 vs Fiber

리눅스 스케줄링에서는 공정성(모든 작업들이 우선순위에 맞는 가중치 값을 가지며 실행 시간을 측정하고 이 실행 시간을 기준으로 선점 과정을 거치며 수행을 할 수 있음 - vruntime 개념)

하지만 Fiber는 리눅스에서와 다르게 작업에 우선순위를 구체적으로 할당하지 않고 `(Immediate, UserBlocking, Normal, Low, Idle)`와 같은 기준으로 할당함

리눅스 : 프로세스가 실행한 가중치가 적용된 실제 물리적 CPU 시간을 정확히 추적하여 우선순위에 따른 가중치를 고려해 사용 시간을 더 늘리거나 줄임(우선순위가 높은 작업에 대해서는 실제 실행한 시간보다 더 적은 시간을 사용한 것처럼 여겨짐)
Fiber : 정확한 실행 시간을 측정하기 보다는 우선순위와 만료 시간에 따라 스케줄링함
ex. 지금 프레임에서 5ms가 남았으니 이 작업을 시작할지(브라우저에게 바로 제어권을 넘길지), 아니면 다음 프레임으로 미룰지(다음 프레임에 제어권을 넘길지), 아니면 할만큼만 하고 제어권 넘길지?

### 이러한 차이점이 생기는 이유

-   리눅스 : 시스템에서는 장기적으로 모든 프로세스가 우선순위에 비례하여 CPU 시간을 할당받도록 보장하는 `공정성`을 매우 중요시 여김!
    -   리눅스는 다중 사용자이기 때문에 한 사용자나 프로세스가 모든 자원을 독점하면 시스템 전체가 불안정해질 수 있기에 `공정성`을 더 따짐
    -   또한 운영체제에서 프로세스 지연은 브라우저에서 작업이 단순히 늦게 처리되는 것보다 더 심각한 문제를 불러 일으킬 수 있음
-   Fiber : 그에 반하여 파이버는 UX를 위한 반응성이 주요 목표로, 사용자 입력, 스크롤 등의 우선순위가 높은 작업은 의도적으로 공정하지 못하게 더 많은 시간을 할당받게 됨!!
    -   파이버는 단일 애플리케이션 내에서 작동하며, 단 한 사용자의 경험만 최적화하면 되기 때문에 `공정성`의 중요도가 더 낮음
    -   UI에서 비가시적 또는 덜 중요한 업데이트는 잠시 지연되어도 사용자 경험에 큰 영향이 없으며, 오히려 중요한 인터렉션이 지연되는 것이 UX적으로 더 큰 불만족을 불러일으킴

결론적으로!! 리눅스의 CFS(vruntime 환경)과 리액트의 Fiber가 해결하고자 하는 문제와 실행되는 환경의 특성의 차이 때문에 이러한 알고리즘적 차이가 발생하는 것이며 각자 최적화된 설계 철학을 부여 받은 것이라고 보면 됨!
