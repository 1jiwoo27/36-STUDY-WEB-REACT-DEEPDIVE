## JSX란?

JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적인 문법이 아니라 독자접인 문법이다.
JSX는 자바스크립트 표준 코드가 아닌 페이스,북이 임의로 만든 새로운 문법이기 때문에, JSX는 반드시 트랜스파일을 거쳐 자바스크립트 코드로 변환된다.

JSX는 트랜스 파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것에 목적을 두고있다.

### 가상 DOM과 리액트 파이버

---

리액트의 특징으로 가장 큰 것중 하나는 실제 DOM이 아니라 가상 DOM을 운영한다는 것이다.

먼저, DOM이란 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고있다.

브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정은 아래와 같다.

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS노드로 구성된 트리 CSSOM을 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display : none 과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6. 5번에사 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.

   - 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정, 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
   - 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정.

### 가상 DOM의 탄생 배경

요즘 대다수의 앱은 렌더링 된 이후 정보를 보여주는 것에 그치지 않고 사용자 인터랙션을 통해 다양한 정보를 노출한다.
특정한 요소의 색상이 변경되는 경우 `페인팅` 만 일어나므로 비교적 빠르게 처리할 수 있지만, 특정한 요소의 노출 여부가 변경되거나 사이즈가 변경되는 등 요소의 위치와 크기를 재계산하는 경우에는 레이아웃이 일어나고 레이아웃은 필연적으로 리페인팅을 발생시킨다.

그리고 DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있는 경우에는 하위 자식 요소도 덩달아 변경돼야 하기 때문에 더 많은 비용을 브라우저와 사용자가 지불하게 된다.

이런 문제점을 해결하기 위해 가상 DOM 개념이 탄생했는데, 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다.

가상 DOM은 웹 페이지가 표시해야 할 DOM을 일단 메모리에 저장하고, 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다.

이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다면 실제로는 여러 번 발생 했을 렌더링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 덜 수 있다.

하지만 이러한 방식이 일반적으로 DOM을 관리하는 방법보다 무조건 빠르지는 않다.

### 리액트 파이버

리액트 파이버는 리액트가 이 가상 DOM을 관리하고, 렌더링 과정 최적화를 가능하게 해준다.

리액트 파이버는 리액트에서 관리하는 자바스크립트 객체의 한 종류인데, 이 파이버는, 또 파이버 재조정자에 의헤 관리된다.

파이버 재조정자(fiber reconciler) 는 가상 DOM과 실제 DOM을 비교해서 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

여기서 말하는 재조정이란 가상 DOM과 실제 DOM을 비교하는 작업이자 일종의 알고리즘이라고 이해하면 된다.

리액트 파이버는 단순히 DOM을 관리하는 역할 뿐만 아니라 리액트에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다.

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

이러한 모든 과정을 비동기로 실행하는 것이 리액트 파이버의역할이다.

```jsx
function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;
  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;
  this.refCleanup = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode;
  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;
  // 이하 프로파일러, __DEV__ 코드는 생략
}
```

보다시피 파이버는 자바스크립트 객체의 일종이다.

여기서 알 수 있는 점은 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다는 것이다.

```jsx
<ul>
  <li>하나</li>
  <li>둘</li>
  <li>셋</li>
</ul>
```

위 구조는 파이버 트리에서 다음과 같이 표현됩니다.

- ul 파이버의 child는 첫번 째 li
- 두 번째 li는 첫 번째 `li` 의 sibling
- 세 번째 `li` 는 두 번째 li의 sibling
- 각각의 `li` 는 return 으로 `ul` 파이버를 참조

Fiber 가 중요한 이유는 기존에 리액트의 동기적으로 처리되던 업데이트 작업을 작게 쪼개고, 우선순위를 정해 스케줄링을 할 수 있게 해주기 때문입니다.

즉, 파이버의 정확한 역할은

> "업데이트를 관리하고, 스케줄링 하는 리액트 내부구조(자바스크립트 객체)"

이 객체를 트리 구조로 만들어서 리액트가 다음과 같은 작업을 하도록 도와줍니다.

- 렌더링 추적
- 작업 스케줄링
- 비동기 처리 지원
- 컴포넌트 간 관계 표현
- 상태 보존

> "Fiber 는 가상 DOM의 진화 버전이자 구현체"

즉, Fiber는 가상 DOM 그 자체가 아니라, 리액트가 가상 DOM을 관리하고 업데이트 하는 방법을 개선한 구조체입니다.

기존에는 가상 DOM 객체를 생성하고, diff 를 비교하고 DOM을 업데이트 하는 과정에서 동기적으로 처리되었기에, 무조건 한번에 계산이 끝났어야 했습니다.

1,000 개의 컴포넌트가 변경되면 1,000 개의 컴포넌트를 한 번에 처리하는 방식

- 가상 DOM: 단순히 UI 구조를 메모리에 저장한 복사본
- Fiber: 그 구조를 기반으로 "언제", "어떻게" 업데이트할지를 결정하는 작업 단위

### 클래스 컴포넌트의 한계

- 데이터의 흐름을 추적하기 어렵다 : 생명주기 메서드의 특성상 state의 흐름을 추적하기가 매우 어렵다. 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있으며, 또 코드 작성 시 메서드의 순서가 강제돼 있는 것이 아니기 때문에 사람이 읽기가 매우 어렵다.

- 로직 재사용이 어려움 : 공통 로직을 고차 컴포넌트나 props로 넘겨야 하는데, 이 방식은 코드가 복잡해질 수 있다.

- 컴포넌트가 커지기 쉬움 : 기능이 많아질수록 생명주기 메서드 사용이 늘어나기에 컴포넌트의 크기가 불필요하게 커질 가능성이 높다.

- 클래스 문법이 어렵다

### 렌더링은 어떻게 일어나는가?

리액트에서의 렌더링이란 브라우저의 렌더링과 차이점이 있다.

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state 의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 말한다.

### 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링 : 사용자가 처음 애플리케이션에 진입하면 브라우저에 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링 : 리렌더링은 처음 애플리케이션에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다.

- 함수 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우 : state를 업데이트하는 함수이기 때문에 이 함수가 실행되면 렌더링이 일어난다.
- 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우 : useReducer도 useState와 마찬가지로 상태와 이 상태를 업데이트하는 함수를 배열로 제공한다.

- 컴포넌트의 key props가 변경되는 경우 : 리액트에서 key는 명시적으로 선언돼 있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props다.

  리액트에서 배열에 key를 명시하지 않으면 콘솔에 경고가 출력되는데, key가 필요한 이유는 다음과 같다.

  리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이기에, 리액트 파이버 트리 구조를 떠올려보면 해당 트리 구조에서 형제 컴포넌트를 구별하기 위해 각자 sibling 이라는 속성값을 사용한다.

  동일한 자식 컴포넌트가 여러 개 있는 구조라면, 리렌더링이 발생할 경우 current 트리와 workInProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 한다.

  이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 key이다.

  이 key가 없다면 파이버 내부에 sibling 인덱스만을 기준으로 판단하게 된다.

- props가 변경되는 경우 : 부모로부터 전달받는 값인 props가 달라지면 이를 사용하는 자식 컴포넌트에서도 변경이 필요하므로 리렌더링이 발생한다.

- 부모 컴포넌트가 렌더링 될 경우 : 부모 컴포넌트가 리렌더링 된다면 자식 컴포넌트도 무조건 리렌더링이 일어난다.

### 렌더와 커밋

렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 즉, 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM 을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계이다.

이 단계에서는 type, props, key 이 세 가지중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해둔다.

커밋 단계는 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다.
이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

이렇게 해서 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트하고, 컴포넌트에서 useLayoutEffect 훅을 호출한다.

중요한 것은 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 점이다. 렌더링을 수행했으나, 커밋 단계를 갈 필요가 없을 경우가 존재한다.

즉, 변경 사항을 계산했는데 아무런 변경사항이 감지되지 않은 상황을 말한다.
