# 2.1장 jsx란

## JSX는

반드시 **트랜스파일러**를 거치고 js로 변환

js내부에서 까다로운 XML스타일의 트리 구문을 좀 더 쉽게 작성하도록!

\*\* 주의 사항

(1) 요소명은 대문자로 : HTML 태그명과 사용자 컴포넌트 구분 위함

(2) JSXElementName : return 밑에 <>형태

`<$></$>` `<_></_>` 까진 가능하지만, 뭐 숫자나 다른 기호는 안됨

(3) JSX 엘리먼트의 자식 값

jsx는 바벨로 변환됨! 이 변환되는 특성에 따라!

직접 React.createElement로 컴포넌트 구성하면 효율적

# 2.2장 가상 DOM & 리액트 파이버

리액트는 가상 DOM을 운영함!

- 브라우저 과정

1. 요청한 주소 방문 → HTML 다운
2. 렌더링 엔진에서 HTML을 파싱해서 DOM노드로 구성된 트리 만듦
3. CSS파일도 다운로드해서 CSSOM만듦
4. 브라우저는 DOM노드를 순회 (유저 눈에 보이는거만 방문)
5. CSSOM 적용 == 페인팅

⇒ BUT 요새는 이제 인터랙션도 늘어나서, 렌더링 이후에도 변경이 이루어짐

이 때, 페이지 변경 될 때, 다른 페이지로 가서 다시 새로 렌더링 받는 방식이 아닌, SPA방식으로! 하나의 페이지에서 재계산 (이런 SPA방식으로 깜박임없이 웹탐색이 이루어지긴 하지만, DOM 관리 부담이 커짐)

### 가상 DOM의 등장

→ 표시할 DOM을 일단 메모리에 저장

→ 변경에 대한 준비 끝나면 실제 DOM에 반영

### React fiber

리액트에서 관리하는 자바스크립트 객체임

- 파이버 재조정자 : 가상 DOM과 실제 DOM을 비교해서, 둘의 차이가 보이면 그 변경된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링 요청
  (즉 재조정 == 비교하는 과정)
- 파이버가 하는 일
  - 작은 단위로 작업을 쪼개고 우선순위를 매김
  - 이전에 했던 작업을 재사용 하거나 필요 없으면 폐기
- 파이버 구조
  - index : 형제들 사이에 자기가 몇번째인지
  - pendingProps : 아직 작업 처리 못한 props
  - memoizedProps : 렌더링 이후에 pendingProps를 여기에 저장 관리함
  - updateQueue : 상태 업데이트, 콜백함수 등의 작업을 담아둠
  - memoizedState : 함수 컴포넌트의 훅 목록
  - alternate : 리액트 트리 2개인데, 이 중 반대편 트리 파이버

파이버는 state가 변경되거나 DOM의 변경이 필요한 시점에 실행

그리고 리액트는 이런 파이버 처리할 때마다 작은 단위로, 또는 우선순위 등에 따라 처리

### fiber 트리

트리가 총 2개 존재하는데, 하나는 현재 모습을 담은 파이버트리이고 다른 하나는 작업 중인 workInprogress트리임!

→ 리액트 파이버 작업이 끝나면, 포인터만 변경해서 workInProgress트리를 현재 트리로 바꿈

**== 더블 버퍼링** (미처 다 그리지 못한 모습을 보여주지 않기 위해 나눠서)

즉, 현재 트리 current을 기준으로 작업하고, 만약 업데이트가 발생하면 새로 바뀐 데이터로 workInProgress트리를 새로 빌드하고, 이 작업이 끝나면 다음 렌더링에 이 트리를 current로

### 즉, 이렇게 리액트 내부의 파이버와 재조정자의 알고리즘 덕분에 대규모 웹어플리케이션 관리를 좀더 효율적으로 가능해짐!

# 2.3장 클래스 컴포넌트 & 함수 컴포넌트

## 1. 클래스 컴포넌트

클래스 선언 후에 컴포넌트를 extends

ex) `React.Component` 나 `React.PureComponent` 로 extends구문 넣음!

```jsx
class Component extends React.Component {
	render(){

	}
	return <></>
}
```

이때, props나 state, constructor활용

- **constructor() :** 이 생성자 함수는 컴포넌트 초기화 되는 시점에 호출, 컴포넌트의 state 초기화

\*\* 근데 constructor 없어도 촉화 가능 (바벨의 특정 트랜스파일 거치면 ㄱㄴ)

\*\* 생성자가 아닌 일반함수로 this호출하면,, undefined로 됨. 전역객체가 바인딩 되기 때문임

```jsx
class Component extends React.Component<SampleProps>{
	private constructor(props: SampleProps){
		super(props) // super()는 상위 컴포넌트에 접근할 수 있게 도움
		this.state = {
			count : 0 ,
			isLimited : 0
		}

	public render(){
		return <></>
	}
}
```

### 클래스 컴포넌트 생명주기

마운트 → 업데이트(변경된 시점) → 언마운트

- **render()**
  컴포넌트가 UI 렌더링 하기 위해 쓰임
  필수 값으로, **render()함수는 항상 순수해야하고 부수효과가 없어야 한다!**
  즉, props나 state값이 들어가면 같은 결과물을 반환, 변경이나 업데이트를 주는 로직 있으면 x
- **componentDidMount()**
  컴포넌트 마운트 되고 준비가 됐다면, 즉시 실행됨.
  render()와 다르게, this.setState()등으로 변경도 가능함
- **componentnDidUpdate()**

  컴포넌트 업데이트 일어난 후에 바로 실행. DOM 업데이트 (setState도 가능)

  근데 제대로된 조건문 없으면, 컴포넌트에서 뭐 하나 props라도 변경되는 순간마다 호출됨

- **componentWillUnmount()**

  컴포넌트가 언마운트되거나 더이상 사용되지 않기 직전에 호출

  메모리 누수나 불필요한 작동을 막기 위한 클린업 함수 호출하기 위함

  ex) 이벤트 지우거나 API호출 빼거나 타이머 제거 등등

- **shouldComponentUpdate()**
  state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링 막고 싶을 때 사용!
  → 컴포넌트에 영향 안 받는 변화에 정의
  \*\* 특정 성능 최적화 상황에서 고려!!

등등

클래스 컴포넌트에는 제공하는 메섣도 있고, 꽤 ㄱㅊ

근데 문제가 있듬!

### 클래스 컴포넌트 한계

1. 데이터 흐름 추적하기 어려움 : state가 어떤식으로 변경해서 렌더링되는지 파악 어려움
2. 애플리케이션 내부 로직의 재사용 어려움 : 상속 클래스의 흐름을 다 쫒아야함
3. 기능이 많아질 수록 컴포넌트 크기가 좀 커짐 , 코드 크기 최적화도 어려움

걍 어려움!! 필요없는 거도 다 렌더링하고 번들에 다 포함됨

# 2. 함수 컴포넌트

클래스 컴포넌트에 비해서 간결함

### 함수형 컴포넌트 vs 클래스 컴포넌트

**(1) 생명주기 메서드의 부재**

그 복잡시려운 생명주기 메서드가 함수형에는 없음. 단순히 props만 받아서 리액트 요소만 반환

클래스는 render메서드가 있는 React.Component를 상속받아서 구현해야함

→ 함수 컴포넌트는 useEffect로 비슷하게 구현도 가능함 (생명주기를 위한 훅은 아니고 state활용해서 동기적으로 부수 효과 만드는거)

**(2) 함수 컴포넌트는 렌더링된 값을 고정, 클래스 컴포넌트는 그러지 못함**

클래스 컴포넌트는 항상 this기준으로 가져오기 때문에, 변경되는 값을 가져오게 됨

근데 함수 컴포넌트에서는 그 작동된 시점의 props값을 가지고 와서 보여줌

얘는 props를 인수로 받기 때문에, 그 값을 사용해서 보여줌

즉 → 클래스 컴포넌트는 this기준으로 렌더링, 함수 컴포넌트는 props와 state 기준으로 렌더링

### 클래스 컴포넌트로만 가능한 자식 에러 처리 등을 위해서라도 알아두면 ㄱㅊ

# 2.4장 렌더링

브라우저의 렌더링 : HTML, CSS 리소스 기반으로 UI 그리는 과정

React에서의 렌더링 : 브라우저가 렌더링에 필요한 DOM 트리 만드는 과정

(현재 props, state 기반으로 어떻게 UI구성하고 DOM결과를 브라우저에 제공할 것인지)

### 렌더링 일어나는 이유

1. 최초 렌더링 : 유저가 처음 어플리케이션 진입
2. 리렌더링
   - 클래스 컴포넌트의 setState
   - 클래스 컴포넌트의 forceUpdate
   - 함수 컴포넌트의 useState의 setter 실행 시
   - 함수 컴포넌트의 useReducer()의 dispatch가 실행
   - 컴포넌트의 props가 변경 될때
     - 이 때 key권장!! (형제 요소들 사이에 식별) key 활용 강제 리렌더링이 가능해짐, 해당 key값만 변경

⇒ 이 상황들 말고는 리렌더링 안됨. 즉, useState 같은 거 안쓰고 그냥 index+=1 하면 렌더링 x

### 리액트의 렌더링 프로세스 = 렌더 + 커밋

렌더링 프로세스에서 변경사항을 수집하고**(==파이버의 재조정 과정)**

이 과정이 끝나면, 하나의 동기 시퀀스로 DOM에 적용해서 보임

(항상 동기식으로 작동하기에, 과정이 길어질 수도 있음!, 비동기로 이루어지면 업뎃 누락될수도 있기에)

(근데, 의도된 우선순위로 컴포넌트 렌더링하는 **동시성 렌더링** 최근에 도입!!)

### 1. 렌더

컴포넌트 렌더링하고 변경사항을 계산

가상 DOM을 비교하는 과정을 거쳐서 필요 컴포넌트를 체크 (type, props, key)

### 2. 커밋

렌더단계의 변경사항을 실제 DOM 에 적용 → **이게 끝나야 브라우저 렌더링이 발생!!!**

즉, 리액트의 렌더링 끝났다고 무조건 DOM 업데이트가 되는 것이 아님 (변경 감지/계산 유무애 따라)

### 일반적인 렌더링 방식

- **A 컴포넌트**는 `B`를 렌더링하고, **B 컴포넌트**는 `useState`로 상태를 관리하며, **버튼 클릭** 시 상태를 변경합니다.
- **상태 변경**(즉, `setCounter`)이 일어나면 `B` 컴포넌트는 다시 렌더링되고, 변경된 `counter` 값이 UI에 반영됩니다.
- React는 상태 변화가 일어날 때마다 **자동으로 렌더링**을 트리거하며, 이를 통해 UI가 동적으로 업데이트됩니다.

# 2.5장 메모제이션

useMemo, useCallback등으로 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위한거!!

최적화 기법으로 많이 쓰임!!

### 1. 꼭 필요한 곳에만 메모이제이션 추가하기!

`ex) function sum(a,b) {return a+b}`

이 때, sum(1,1)을 계산해둔 걸 다시 꺼낼 때 메모리에서 다시 끄집어낼 지 or 그냥 다시 새로 계산?

뭐가 더 빠를까 → 이런 간단 연산은 그냥 다시 수행하는 게 더 빠를거임

왜냐!! 메모이제이션에도 결국 비용이 둠. 어딘가의 메모리에 저장하고 재계산 확인 등의 과정이 있음

즉, memo에 선택권을 줬다는 것은 항상 필요한 것은 아니란 거임

이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유

→ 미래의 어떤 경우에 따라서는 이 캐시가 무효화 될 수도 있음. 언제나 최적화 보장은 x

### 2. 렌더링 과정의 비용은 비싸다. 다 메모이제이션 하자?

메모이제이션을 위해선 CPU와 메모리 사용해서 이전 렌더링 결과물 저장하 것이고, 다시 비교가 필요

근데!! 리액트의 기본적인 “재조정 알고리즘”이 있기 떄문에, 어차피 이전 결과물 가지고는 있음

대신 memo 하지 않았을 때의 문제 있긴함

1. 리렌더링 비용
2. 컴포넌트 내부의 복잡한 로직 재실행
3. 리액트가 구트리와 신트리 비교

→ 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장

이 props로 넘어갔을 때 참조 투명성을 유지하기 위해서는 useCallback을 사용하는 것이 좋음 useMemo 또한 마찬가지. props로 넘어가거나 이를 활용할 여지가 있다면 사용하는 것이 좋음

### 성능에 대해서 지속적으로 모니터링하고 관찰하는 것보다 섣부른 메모이제이션 최적화가 주는 이점이 더 클 수 있음
